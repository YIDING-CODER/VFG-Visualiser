<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello World</title>
</head>
<!-- Load Pixi JS -->
<script src="pixi.min.js"></script>
<!-- Used to load Json file -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<body>
    <script type="text/javascript">

        // Load the VFG json file, it will be returned by Planimation API later.
        $.getJSON("vfgFiles/grid.vfg", function (vfg) {
            // Set the canvas size
            let width = 600, height = 600;

            //Aliases
            let Application = PIXI.Application,
                loader = PIXI.loader,
                resources = PIXI.loader.resources,
                Sprite = PIXI.Sprite;

            //Create a Pixi Application
            let app = new Application({
                width: width,
                height: height,
                antialias: true,
                transparent: true,
                resolution: 1
            }
            );

            // The following two line is to change the canvas origin from top left to bottom left.
            app.stage.position.y = app.renderer.height / app.renderer.resolution;
            app.stage.scale.y = -1;

            //Add the canvas that Pixi automatically created for you to the HTML document
            document.body.appendChild(app.view);


            // Code to get the image texture from VFG File
            var base64imgs = []
            for (var i = 0; i < vfg.imageTable.m_keys.length; i++) {
                var obj = {}
                obj.name = vfg.imageTable.m_keys[i];
                obj.url = "data:image/png;base64," + vfg.imageTable.m_values[i];
                base64imgs.push(obj)
            }

            //load based64 images and run the `setup` function when it's done
            loader
                .add(base64imgs)
                .on("progress", loadProgressHandler)
                .load(setup);


            //This `setup` function will run when the image has loaded
            function setup() {
                console.log("All files loaded");
                currentStage = 0
                entStage = vfg.visualStages.length;

                // get all the sprites and it's attributes for the current stage.
                sprites = vfg.visualStages[currentStage].visualSprites;

                // Add all the sprites to the canvas
                for (var i = 0; i < sprites.length; i++) {
                    if (sprites[i].showname) {
                        app.stage.addChild(getSpriteWithName(sprites[i]));
                    } else {
                        app.stage.addChild(getSprite(sprites[i]));
                    }
                    // sort the children based on their zIndex
                    app.stage.children.sort((itemA, itemB) => itemA.zIndex - itemB.zIndex);

                }

                //Capture the keyboard arrow keys
                let left = keyboard("ArrowLeft"),
                    right = keyboard("ArrowRight");
                var updated = false;

                //Left arrow key `press` method
                left.press = () => {
                    if (currentStage > 0 && updated === false) {
                        currentStage = currentStage - 1;
                        updated = true
                    }
                };
                //Left arrow key `release` method
                left.release = () => {
                    updated = false;
                };
                //Right
                right.press = () => {
                    if (currentStage < entStage - 1 && updated === false) {
                        currentStage = currentStage + 1;
                        updated = true
                    }
                };
                right.release = () => {
                    updated = false;
                };

            
                //call update canvas 60 times per second
                app.ticker.add(delta => updateCanvas(delta));
            }

            function getSprite(sprite) {
                textureName = sprite.prefabimage
                var spriteObj = new Sprite(resources[textureName].texture);
                spriteObj.texture.rotate = 8
                spriteObj.name = sprite.name;
                spriteObj.position.set(sprite.minX * width, sprite.minY * width);
                spriteObj.width = (sprite.maxX - sprite.minX) * width;
                spriteObj.height = (sprite.maxY - sprite.minY) * height;
                spriteObj.tint = RGBAToHexA(sprite.color.r, sprite.color.g, sprite.color.b, sprite.color.a);
                spriteObj.zIndex = sprite.depth;
                if ('rotate' in sprite) {
                    spriteObj.anchor.set(0.5, 0.5);
                    spriteObj.rotation = sprite.rotate * Math.PI / 180;
                    spriteObj.position.set(sprite.minX * width + (sprite.maxX - sprite.minX) * width / 2, sprite.minY * width);
                }
                return spriteObj;

            }
            function getSpriteWithName(sprite) {
                // get the image type, block,table,etc
                textureName = sprite.prefabimage

                // create sprite/object to display on the canvas, the location(local) is set to be the bottom left
                var spriteObj = new Sprite(resources[textureName].texture);
                spriteObj.texture.rotate = 8
                spriteObj.name = sprite.name;
                spriteObj.position.set(0, 0);
                spriteObj.width = (sprite.maxX - sprite.minX) * width;
                spriteObj.height = (sprite.maxY - sprite.minY) * height;
                spriteObj.tint = RGBAToHexA(sprite.color.r, sprite.color.g, sprite.color.b, sprite.color.a);

                // create text and put it in the middle of the object
                var sprintText = new PIXI.Text(sprite.name, { fontFamily: 'Arial', fontSize: 20, fill: 0x000000 });
                sprintText.texture.rotate = 8;
                sprintText.name = sprite.name + "Text";
                sprintText.anchor.set(0.5, 0.5);
                sprintText.position.set(spriteObj.width / 2, spriteObj.height / 2);

                // Combine the sprite/object and text as a new object, and set the location(global)
                spritWithText = new PIXI.Container();
                spritWithText.addChild(spriteObj);
                spritWithText.addChild(sprintText);
                spritWithText.position.set(sprite.minX * width, sprite.minY * width);
                spritWithText.name = spriteObj.name;
                if ('rotate' in sprite) {
                    updateRotateSprite(spritWithText,sprite);
                }
                spritWithText.zIndex = sprite.depth;
                return spritWithText;
            }

            function updateCanvas(delta) {

                //Update the current game state:
                play(delta);
            }

            // Update the scene based on the new stage information
            function play(delta) {

                sprites = vfg.visualStages[currentStage].visualSprites;

                for (var i = 0; i < sprites.length; i++) {
                    // get the previous loaded sprite
                    var spriteUpdate = app.stage.getChildByName(sprites[i].name);
                    // Update the sprite location with new position
                    spriteUpdate.position.set(sprites[i].minX * width, sprites[i].minY * width);

                    // Update the sprite with rotate value
                    if ('rotate' in sprites[i]) {
                        updateRotateSprite(spriteUpdate,sprites[i]);
                    }
                }
            }
            function updateRotateSprite(oldSprite,newSprite){
                oldSprite.anchor.set(0.5, 0.5);
                oldSprite.rotation = newSprite.rotate * Math.PI / 180;
                oldSprite.position.set(newSprite.minX * width + (newSprite.maxX - newSprite.minX) * width / 2,newSprite.minY * width);
            }
        });

        // Progress function, we may use it in future
        function loadProgressHandler(loader, resource) {

//Display the file `url` currently being loaded
console.log("loading: " + resource.url);

//Display the percentage of files currently loaded
console.log("progress: " + loader.progress + "%");

//If you gave your files names as the first argument 
//of the `add` method, you can access them like this
//console.log("loading: " + resource.name);
}

// Copied from online, used for tracking key board event.
function keyboard(value) {
let key = {};
key.value = value;
key.isDown = false;
key.isUp = true;
key.press = undefined;
key.release = undefined;
//The `downHandler`
key.downHandler = event => {
    if (event.key === key.value) {
        if (key.isUp && key.press) key.press();
        key.isDown = true;
        key.isUp = false;
        event.preventDefault();
    }
};

//The `upHandler`
key.upHandler = event => {
    if (event.key === key.value) {
        if (key.isDown && key.release) key.release();
        key.isDown = false;
        key.isUp = true;
        event.preventDefault();
    }
};

//Attach event listeners
const downListener = key.downHandler.bind(key);
const upListener = key.upHandler.bind(key);

window.addEventListener(
    "keydown", downListener, false
);
window.addEventListener(
    "keyup", upListener, false
);

// Detach event listeners
key.unsubscribe = () => {
    window.removeEventListener("keydown", downListener);
    window.removeEventListener("keyup", upListener);
};

return key;
}

// Convert RGBA color to hex value
function RGBAToHexA(r, g, b, a) {
r = Math.round(r * 255).toString(16);
g = Math.round(g * 255).toString(16);
b = Math.round(b * 255).toString(16);
a = Math.round(a * 255).toString(16);

if (r.length == 1)
    r = "0" + r;
if (g.length == 1)
    g = "0" + g;
if (b.length == 1)
    b = "0" + b;
if (a.length == 1)
    a = "0" + a;

return "0x" + r + g + b;
}

    </script>
</body>

</html>